<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HikariCP源码研读</title>
      <link href="/2025/07/26/HikariCP-source-study/"/>
      <url>/2025/07/26/HikariCP-source-study/</url>
      
        <content type="html"><![CDATA[<h1 id="HikariCP源码研读"><a href="#HikariCP源码研读" class="headerlink" title="HikariCP源码研读"></a>HikariCP源码研读</h1><h2 id="创建的流程"><a href="#创建的流程" class="headerlink" title="创建的流程"></a>创建的流程</h2><ul><li>新建HikariConfig -&gt; 新建HikariDataSource -&gt; getConnection</li></ul><h2 id="重点类及说明"><a href="#重点类及说明" class="headerlink" title="重点类及说明"></a>重点类及说明</h2><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td><code>HikariDataSource</code></td><td>对外数据源接口 负责对外暴露连接获取功能 管理连接池生命周期</td></tr><tr><td><code>HikariConfig</code></td><td>加载配置、初始化参数</td></tr><tr><td><code>HikariPool</code></td><td>连接池核心，维护连接的创建、回收、驱逐和调度</td></tr><tr><td><code>PoolEntry</code></td><td>连接池中的连接包装，保存连接状态和元数据和定时任务和Statement列表</td></tr><tr><td><code>ConcurrentBag</code></td><td>并发连接管理容器</td></tr><tr><td><code>ProxyConnection</code></td><td>对JDBC的连接的代理，增强功能（如泄漏检测、状态管理）</td></tr><tr><td><code>ProxyStatement</code></td><td>对JDBC的语句的代理，增强功能（如泄漏检测、状态管理）</td></tr><tr><td><code>ProxyResultSet</code></td><td>对JDBC的结果集的代理，增强功能（如泄漏检测、状态管理）</td></tr><tr><td><code>ConcurrentBag&lt;T&gt;</code></td><td>存PoolEntry的地方 高性能容器 共享列表 ThreadLocal SynchronousQueue FastList</td></tr><tr><td><code>FastList</code></td><td>没有边界检测的高性能List</td></tr><tr><td><code>SynchronousQueue</code></td><td>没有缓冲区的 避免加锁和上下文切换 减少内存开销</td></tr><tr><td><code>ProxyLeakTask</code></td><td>连接泄漏检测任务 超过一定时间没归还认为是泄漏</td></tr><tr><td><code>SuspendResumeLock</code></td><td>连接池关闭或重配置期间阻止线程获取连接的工具类</td></tr><tr><td><code>ProxyFactory</code></td><td>(通过Javassist生成实现)生成各种代理实例，注入增强代码</td></tr><tr><td><code>HouseKeeper</code></td><td>周期性维护池状态 回收过期连接 补充新连接</td></tr><tr><td><code>JavassistProxyFactory</code></td><td>比动态代理快 减少反射开销 功能增强 避免冗长代码</td></tr><tr><td><code>MetricsTrackerDelegate</code></td><td>监控</td></tr></tbody></table><h2 id="常用类详解"><a href="#常用类详解" class="headerlink" title="常用类详解"></a>常用类详解</h2><h3 id="HikariConfig"><a href="#HikariConfig" class="headerlink" title="HikariConfig"></a>HikariConfig</h3><p>HikariCP的配置, HikariDatasource继承了这个类, 创建数据源的时候需要传入一个HikariConfig对象, 然后会拷贝到HikariDatasource对象的父类字段上</p><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><table><thead><tr><th>配置项</th><th>说明</th><th>建议</th></tr></thead><tbody><tr><td><code>jdbcUrl</code></td><td>数据库连接URL</td><td>必填</td></tr><tr><td><code>username</code></td><td>数据库用户名</td><td>必填</td></tr><tr><td><code>password</code></td><td>数据库密码</td><td>必填</td></tr><tr><td><code>driverClassName</code></td><td>JDBC驱动类名</td><td>可选 自动推导</td></tr></tbody></table><h4 id="连接池大小相关"><a href="#连接池大小相关" class="headerlink" title="连接池大小相关"></a>连接池大小相关</h4><table><thead><tr><th>配置项</th><th>说明</th><th>建议</th></tr></thead><tbody><tr><td><code>maximumPoolSize</code></td><td>最大连接数 默认10</td><td>根据并发情况设置 一般为 CPU 核数 × 2</td></tr><tr><td><code>minimumIdle</code></td><td>最小空闲连接数 默认&#x3D;maximumPoolSize</td><td>可设为0节省资源 或设为相同保持连接稳定</td></tr><tr><td><code>idleTimeout</code></td><td>空闲连接的最大存活时间 默认600000ms</td><td>如果 minimumIdle 小于 maximumPoolSize 可调低</td></tr><tr><td><code>maxLifetime</code></td><td>连接最大生命周期 默认1800000ms</td><td>设置略小于数据库自身连接超时</td></tr><tr><td><code>keepaliveTime</code></td><td>保持连接活跃的ping间隔 默认0禁用</td><td>设置小于数据库空闲超时时间 如600000ms</td></tr></tbody></table><h4 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h4><table><thead><tr><th>配置项</th><th>说明</th><th>建议</th></tr></thead><tbody><tr><td><code>connectionTimeout</code></td><td>等待连接的最大时间 默认30000ms</td><td>视业务情况设为1000~5000ms</td></tr><tr><td><code>validationTimeout</code></td><td>校验连接的超时时间 默认5000ms</td><td>可适当调小</td></tr></tbody></table><h4 id="SQL执行相关"><a href="#SQL执行相关" class="headerlink" title="SQL执行相关"></a>SQL执行相关</h4><table><thead><tr><th>配置项</th><th>说明</th><th>建议</th></tr></thead><tbody><tr><td><code>autoCommit</code></td><td>是否自动提交事务</td><td>需要手动控制事务时关闭</td></tr><tr><td><code>readOnly</code></td><td>是否只读连接</td><td>读写分离 只读操作可设为true</td></tr><tr><td><code>transactionIsolation</code></td><td>事务隔离级别</td><td>可选配置</td></tr></tbody></table><h4 id="连接检测与泄漏排查"><a href="#连接检测与泄漏排查" class="headerlink" title="连接检测与泄漏排查"></a>连接检测与泄漏排查</h4><table><thead><tr><th>配置项</th><th>说明</th><th>建议</th></tr></thead><tbody><tr><td><code>connectionTestQuery</code></td><td>连接校验SQL（如 SELECT 1）</td><td>不推荐设置 用 isValid 更高效</td></tr><tr><td><code>leakDetectionThreshold</code></td><td>连接泄漏检测阈值 默认0(关闭)</td><td>设为业务超时时间如3000ms进行排查</td></tr></tbody></table><hr><h4 id="示例配置代码"><a href="#示例配置代码" class="headerlink" title="示例配置代码"></a>示例配置代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新建配置对象</span></span><br><span class="line">    <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">    <span class="comment">//基础配置</span></span><br><span class="line">    config.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">    config.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    config.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//各种参数</span></span><br><span class="line">    config.setMaximumPoolSize(<span class="number">20</span>);</span><br><span class="line">    config.setMinimumIdle(<span class="number">5</span>);</span><br><span class="line">    config.setIdleTimeout(<span class="number">600000</span>);</span><br><span class="line">    config.setMaxLifetime(<span class="number">1800000</span>);</span><br><span class="line">    config.setKeepaliveTime(<span class="number">300000</span>);</span><br><span class="line">    config.setConnectionTimeout(<span class="number">5000</span>);</span><br><span class="line">    </span><br><span class="line">    config.setLeakDetectionThreshold(<span class="number">3000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建数据源</span></span><br><span class="line">    <span class="type">HikariDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 使用连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// conn是代理对象 这里的关闭会归还给连接池</span></span><br><span class="line">    conn.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="HikariDatasource"><a href="#HikariDatasource" class="headerlink" title="HikariDatasource"></a>HikariDatasource</h3><p>Hikari数据源, 内有懒加载, 通常会创建多个数据源, 用于读写分离, 或连接多个数据库.</p><p>实现了了DataSource接口, 部分方法未实现.</p><hr><h3 id="PoolEntry与ProxyConnection"><a href="#PoolEntry与ProxyConnection" class="headerlink" title="PoolEntry与ProxyConnection"></a>PoolEntry与ProxyConnection</h3><p>PoolEntry是池子里的一个条目, 内有底层连接对象, 访问时间, 借出时间, 连接状态, 驱逐标记, 生命周期定时任务, 打开的SQL语句列表, 只读, 自动提交等字段. 使用原子引用更新状态.</p><p>ProxyConnection是代理连接, 由ProxyFactory创建, 内有底层连接, 泄漏检测任务, 打开的语句列表, 以及各种配置标记, 调用底层conn的方法时进行其他操作, 进行功能增强, 有dirtyBits的判断, isCommitStateDirty的标记等. 其中close方法会把连接归还到连接池, 以及重置各种状态.</p><hr><h3 id="ProxyStatement和ProxyResultSet"><a href="#ProxyStatement和ProxyResultSet" class="headerlink" title="ProxyStatement和ProxyResultSet"></a>ProxyStatement和ProxyResultSet</h3><p>指定操作前, 调用代理连接的markCommitStateDirty方法进行标记, 用于在归还连接的时候判断, 如果不是自动提交还脏了, 则需要进行rollback</p><hr><h3 id="HikariPool"><a href="#HikariPool" class="headerlink" title="HikariPool"></a>HikariPool</h3><p>数据库连接池, 内有大量配置字段, 挂起恢复锁, 清理任务, 各种工厂和任务. 连接条目放在ConcurrentBag内. getConnection方法用于获取连接, 先获取挂起恢复锁, 再从ConcurrentBag借一个连接, metricsTracker记录状态</p><hr><h3 id="ConcurrentBag"><a href="#ConcurrentBag" class="headerlink" title="ConcurrentBag"></a>ConcurrentBag</h3><p>优于LinkedBlockingQueue和LinkedTransferQueue的并发集合, 适用于连接池, 使用ThreadLocal避免锁和AQS, 使用CopyOnWriteArrayList存储所有资源用于共享, 使用SynchronousQueue避免加锁复制和排队, 避免上下文和内存开销, 使用FastList提高访问效率.</p><p>borrow时, 先从ThreadLocal的List内获取, 如果没有则遍历共享列表, 如果还没有则从SynchronousQueue获取(同步等待归还连接).</p><p>requite时, 如果有等待的则通过SynchronousQueue递交, 否则归还到ThreadLocal的List内.</p><hr><h3 id="FastList"><a href="#FastList" class="headerlink" title="FastList"></a>FastList</h3><p>轻量级列表, 内部用数组实现, 避免了ArrayList的一些边界检查和扩容开销, 适合高频增删, 尤其在连接池这种场景下效率更好.</p><hr><h3 id="JavassistProxyFactory"><a href="#JavassistProxyFactory" class="headerlink" title="JavassistProxyFactory"></a>JavassistProxyFactory</h3><p>字节码代理工厂, 填充代码用的, 构建时执行, 通过插件或脚本触发. 给方法加上try-catch, 添加checkException检测异常, 内有检测连接失效, 处理链接泄漏, 状态同步等功能. 再把代理工厂内的方法替换成新生成的类. 简化了繁琐且重复的代码.</p><hr><h3 id="ProxyLeakTask"><a href="#ProxyLeakTask" class="headerlink" title="ProxyLeakTask"></a>ProxyLeakTask</h3><p>泄漏检测任务, 任务触发时, 代表很久没有归还, 则认为是泄漏, 打印日志警告.</p><hr><h3 id="HouseKeeper"><a href="#HouseKeeper" class="headerlink" title="HouseKeeper"></a>HouseKeeper</h3><p>定期维护连接池状态, 清理超时空闲链接, 调整连接池大小, 检测连接泄漏, 更新时间基准.</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HikariCP 是一个高性能 JDBC 连接池框架 它通过一个池类(HikariPool)统一管理连接对象(PoolEntry)并对原生连接封装为代理连接(ProxyConnection)实现连接复用 事务控制 泄漏检测等功能 框架通过配置类(HikariConfig)集中配置连接参数 采用 Javassist 动态生成代理类提升性能 同时利用后台线程(HouseKeeper)定期清理无效连接 保证连接池健康稳定stList</p>]]></content>
      
      
      <categories>
          
          <category> 源码研读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> 数据库连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2025/07/25/test/"/>
      <url>/2025/07/25/test/</url>
      
        <content type="html"><![CDATA[<h2 id="测试页面"><a href="#测试页面" class="headerlink" title="测试页面"></a>测试页面</h2><p>这是一个测试页面 下面是一段lua代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer.runAfter</span><span class="params">(interval, f, ...)</span></span></span><br><span class="line">    <span class="keyword">local</span> timerid = NewSession()</span><br><span class="line">    <span class="keyword">local</span> args = &#123; farg = &#123; ... &#125;, timerid = timerid &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">if</span> Timer.CheckSession(args.timerid) <span class="keyword">then</span></span><br><span class="line">            f(<span class="built_in">table</span>.<span class="built_in">unpack</span>(args.farg))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        RecoverSession(args.timerid)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    skynet.timeout(interval, run)</span><br><span class="line">    <span class="keyword">return</span> timerid</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 卡牌对战 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
